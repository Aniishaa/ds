//  searching  and sorting -------------------------------------
#include<iostream>
#include<string.h>
using namespace std;
typedef struct student
{
int roll_num;
char name [20];
float marks;
}stud;


void create(stud s[20],int n);
void display(stud s[20],int n);
void bubble_sort(stud s[20],int n);
void insertionSort(stud s[20],int n);
void quick_sort(stud s[20],int,int);
int partition(stud s[20],int,int);
void search(stud s[20],int n,int key);
int bsearch(stud s[20], char x[20],int low,int high);

int main()
{
stud s[20];
int ch,n,key,result;
char x[20];
do
{
cout<<"\n 1) Create Student Database ";
cout<<"\n 2) Display Student Records ";
cout<<"\n 3) Bubble Sort ";
cout<<"\n 4) Insertion Sort ";
cout<<"\n 5) Quick Sort ";
cout<<"\n 6) Linear search ";
cout<<"\n 7) Binary search  ";
cout<<"\n 8) Exit ";
cout<<"\n Enetr Your Choice:=";
cin>>ch;
switch(ch)
{
case 1:
cout<<"\n Enter The Number Of Records:=";
cin>>n;
create(s,n);
break;
case 2:
display(s,n);
break;
case 3:
bubble_sort(s,n);
break;
case 4:
insertionSort(s,n);
break;
case 5:
quick_sort(s,0,n-1);
cout<<"\n"<< "\t"<< "Roll No"<< "\t"<<" Name" <<"\t"<< "Marks";
for(int i=n-1; i>=n-10; i--)
{
	cout<<"\n";
cout<<"\t "<< s[i].roll_num<<"\t "<<s[i].name<<"\t "<<s[i].marks;

}
break;
case 6:
cout<<"\n Enter the marks which u want to search:=";
cin>>key;
search(s,n,key);
break;



case 7:
cout<<"\n Enter the name of student  which u want to search:=";
cin>>x;



       insertionSort(s,n);
       result=bsearch(s,x,0,(n-1));
       if(result==-1)
       {
       cout<<" \n Student name you want to search for is not present ! \n";
       }
       else
       {
       cout<<" \n The student  is present :\t" << s[result].name;
       }
       break;



case 8:return 0;
      default:cout<<"\n Invalid choice !! Please enter your choice again."<<endl;
}
}while(ch!=8);
}
void create(stud s[20],int n)
{
int i;
for(i=0;i<n;i++)
{
cout<<"\n Enter the roll number:=";
cin>>s[i].roll_num;
cout<<"\n Enter the Name:=";
cin>>s[i].name;
cout<<"\n Enter the marks:=";
cin>>s[i].marks;
}
}
void display(stud s[20],int n)
{
int i;
cout<<"\n"<< "\t"<< "Roll No"<< "\t"<<" Name" <<"\t"<< "Marks";
for(i=0;i<n;i++)
{
	cout<<"\n";
cout<<"\t "<< s[i].roll_num<<"\t "<<s[i].name<<"\t "<<s[i].marks;
}
}



//bubble sort to sort in ascending order on roll number


void bubble_sort(stud s[20],int n)
{
int i,j;
stud temp;
for(i=1;i<n;i++)
{
for(j=0;j<n-i;j++)
{
if(s[j].roll_num>s[j+1].roll_num)
{
temp=s[j];
s[j]=s[j+1];
s[j+1]=temp;
}
}
}
}

// insertion sort to sort on names in ascending order

void insertionSort(stud s[20], int n)  
{  
    int i,  j;  
    stud  key;
    for (i = 1; i < n; i++) 
    {  
        key= s[i];  
        j = i - 1;  
  
        /* Move elements of arr[0..i-1], that are  
        greater than key, to one position ahead  
        of their current position */
        while (j >= 0 && strcmp(s[j].name, key.name) >0)
        {  
            s[j + 1]= s[j];  
            j = j - 1;  
        }  
        s[j + 1]= key;  
    }  
}  
  


//Quick sort to sort on marks 

void quick_sort(stud s[20], int l,int u)
{
    int j;
    if(l<u)
    {
        j=partition(s,l,u);
        quick_sort(s,l,j-1);
        quick_sort(s,j+1,u);
    }
}
 
int partition(stud s[20], int l,int u)
{
    int i,j;
	 stud temp, v;
    
    v=s[l];
    i=l;
    j=u+1;
    
    do
    {
        do
            i++;
            
        while(s[i].marks<v.marks&&i<=u);
        
        do
            j--;
        while(v.marks<s[j].marks);
        
        if(i<j)
        {
            temp=s[i];
            s[i]=s[j];
            s[j]=temp;
        }
    }while(i<j);
    
    s[l]=s[j];
    s[j]=v;
    
    return(j);
}


// linear search for marks if more than one student having same marks print all of them 

void search(stud s[20],int n,int key)
{
int i;

cout<<"\n"<< "\t"<< "Roll No"<< "\t"<<" Name" <<"\t"<< "Marks";


for(i=0;i<n;i++)
{
if(key==s[i].marks)
{
cout<<"\n\t "<< s[i].roll_num<<"\t "<<s[i].name<<"\t "<<s[i].marks;
}

}

}


int bsearch(stud s[20], char x[20],int low,int high)
{
int mid;
while(low<=high)
{
mid=(low+high)/2;
if(strcmp(x,s[mid].name)==0)
{
return mid;
}
else if(strcmp(x,s[mid].name)<0)
{
high=mid-1;
}
else
{
low=mid+1;
}
}
return -1;
}


// end--------------------------------------------------------------------




//    stack opt---------------------------------------------------------

#include<iostream>
using namespace std;
typedef struct node
{
char data;
struct node *next;
}node;
class stack
{
node *top;
public:
stack()
{
top=NULL;
}
int isempty()
{
if(top==NULL)
return 1;
return 0;
}
void push(char x)
{
node *p;
p=new node();
p->data=x;
p->next=top;
top=p;
}
char pop()
{
node *p;
char x;
p=top;
x=p->data;
top=top->next;
delete(p);
return x;
}
char topdata()
{
return top->data;
}
};
void infix_postfix(char infix[20],char postfix[20]);
void reverse(char a[20],char b[20]);
void infix_prefix(char infix[20],char prefix[20]);
int evaluate(int op1,int op2,char op);
void evaluate_postfix(char postfix[20]);
int precedence(char x);
void evaluate_prefix(char prefix[20]);
int main()
{
char infix[20],token,postfix[20],prefix[20];
int ch,result;
do
{	
cout<<"\n1. infix to postfix expansion";
cout<<"\n2. infix to prefix expansion";
cout<<"\n3. evaluate postfix";
cout<<"\n4. evaluate prefix";
cout<<"\n5. exit";
cout<<"\nenter your choice:";
cin>>ch;
switch(ch)
{
case 1:cout<<"\n Enter  Infix expression";
cin>>infix;
infix_postfix(infix,postfix);
cout<<"\n Postfix:="<<postfix;
break;	
case 2:	cout<<"\n Enter infix expression";
cin>>infix;				
infix_prefix(infix,prefix);
cout<<"\n prefix expression is"<<prefix;
break;		
case 3:				
evaluate_postfix(postfix);
break;	
case 4:
evaluate_prefix(prefix);
break;			
}
}
while(ch!=5);		
}
void infix_postfix(char infix[20],char postfix[20])
{
stack s;
int i,j=0;
char token,x;
for(i=0;infix[i]!='\0';i++)
{
token=infix[i];
if(isalnum(token))
{
postfix[j]=token;
j++;
}
else
{
if(token=='(')
s.push(token);
else if(token==')')
{
while((x=s.pop())!='(')
{
postfix[j]=x;
j++;
}
}
else
{
while(s.isempty()!=1 && precedence(token)<=precedence(s.topdata()) )
{
postfix[j]=s.pop();
j++;
}
s.push(token);
}
}
}
while(s.isempty()!=1)
{
postfix[j]=s.pop();
j++;
}
postfix[j]='\0';
}
void reverse(char a[20],char b[20])
{
int i,j=0;
for(i=0;a[i]!='\0';i++)
{
}
i--;
for(j=0;i>=0;j++,i--)
{
if(a[i]=='(')
b[j]=')';
else if(a[i]==')')
b[j]='(';
else
b[j]=a[i];
}
b[j]='\0';
}	
void infix_prefix(char infix[20],char prefix[20])
{
char prefix1[20],infix1[20];
reverse(infix,infix1);
infix_postfix(infix1,prefix1);
reverse(prefix1,prefix);
}
int precedence(char x)
{
if(x=='(')
return 0;
if(x=='+' || x=='-')
return 1;
if(x=='*' || x=='/')
	return 2;
return 3;
}
int evaluate(int op1,int op2,char op)
{
if(op=='+')
return op1+op2;
if(op=='-')
return op1-op2;
if(op=='*')
return op1*op2;
if(op=='/')
return op1/op2;
if(op='%')
return op1%op2;
}
void evaluate_postfix(char postfix[20])
{
stack s;
int i,op1,op2,result;
char token;
int x;
for(i=0;postfix[i]!='\0';i++)
{
token=postfix[i];
if(isalnum(token))
{
cout<<"enter the value"<<token;
cin>>x;
s.push(char(x));
}
else
{
op2=s.pop();
op1=s.pop();
result=evaluate(op1,op2,token);
s.push(char(result));
}
}
result=s.pop();
cout<<"result="<<result;
}
void evaluate_prefix(char prefix[20])
{
stack s;
int i,op1,op2,result;
char token;
int x;
for(i=0;prefix[i]!='\0';i++) {}
	
i--;
	
for(;i>=0;i--)
{
token=prefix[i];

if(isalnum(token))
{
cout<<"enter the value"<<token;
cin>>x;
s.push(char(x));
}
else
{
op1=s.pop();
op2=s.pop();
result=evaluate(op1,op2,token);
s.push(char(result));
}
}
result=s.pop();
cout<<"result="<<result;
}

//end----------------------------------------------------------------------------

// CIRCULAR QUEUE    ----------------------------------------------

#include <iostream>
using namespace std;

int cqueue[5];
int front = -1, rear = -1, n=5;

void insertCQ(int val) {
   if ((front == 0 && rear == n-1) || (front == rear+1)) {
      cout<<"Queue Overflow \n";
      return;
   }
   if (front == -1) {
      front = 0;
      rear = 0;
   } else {
      if (rear == n - 1)
      rear = 0;
      else
      rear = rear + 1;
   }
   cqueue[rear] = val ;
}
void deleteCQ() {
   if (front == -1) {
      cout<<"Queue Underflow\n";
      return ;
   }
   cout<<"Element deleted from queue is : "<<cqueue[front]<<endl;

   if (front == rear) {
      front = -1;
      rear = -1;
   } else {
      if (front == n - 1)
      front = 0;
      else
      front = front + 1;
   }
}



void displayCQ_forward() {
   int f = front, r = rear;
   if (front == -1) {
      cout<<"Queue is empty"<<endl;
      return;
   }
   cout<<"Queue elements are :\n";
   if (f <= r) {
      while (f <= r){
         cout<<cqueue[f]<<" ";
         f++;
      }
   } else {
      while (f <= n - 1) {
         cout<<cqueue[f]<<" ";
         f++;
      }
      f = 0;
      while (f <= r) {
         cout<<cqueue[f]<<" ";
         f++;
      }
   }
   cout<<endl;
}


void displayCQ_reverse() {
   int f = front, r = rear;
   if (front == -1) {
      cout<<"Queue is empty"<<endl;
      return;
   }
   cout<<"Queue elements are :\n";
   if (f <= r) {
      while (f <= r){
         cout<<cqueue[r]<<" ";
         r--;
      }
   } else {
   	
   	
      while (r>=0) {
         cout<<cqueue[r]<<" ";
         r--;
      }
      r=n-1;
      while (r>=f) {
         cout<<cqueue[r]<<" ";
         r--;
      }
   }
   cout<<endl;
}





int main() {

   int ch, val;
   cout<<"1)Insert\n";
   cout<<"2)Delete\n";
   cout<<"3)Display forward\n";
   cout<<"4)Display reverse\n";
   cout<<"5)Exit\n";
   do {
      cout<<"Enter choice : "<<endl;
      cin>>ch;
      switch(ch) {
         case 1:
         cout<<"Input for insertion: "<<endl;
         cin>>val;
         insertCQ(val);
         break;
         case 2:
         deleteCQ();
         break;
         case 3:
         displayCQ_forward();
         break;
		case 4:
         displayCQ_reverse();
         break;
         case 5:
         cout<<"Exit\n";
         break;
         default: cout<<"Incorrect!\n";
      }
   } while(ch != 5);
   return 0;
}

//end-----------------------------------------------------------------


// EXPRESSION, TREE TRAVERSING  -------------------------------------------------


 #include<iostream>
using namespace std;

typedef struct node
{
	char data;
	struct node *left;
	struct node *right;

}node;

typedef struct stacknode
{
	node* data;
	struct stacknode *next;
}stacknode;

class stack
{
	stacknode *top;
	public:
	stack()
	{
		top=NULL;
	}
	node* topp()
	{
		return (top->data);
	}
	int isempty()
	{
		if(top==NULL)
			return 1;
		return 0;
	}

	void push(node* a)
	{
		stacknode *p;
		p=new stacknode();
		p->data=a;
		p->next=top;
		top=p;
	}

	node* pop()
	{       stacknode *p;
		node* x;
		x=top->data;
		p=top;
		top=top->next;

		return x;
	}
};

node* create_pre(char prefix[10]);
node* create_post(char postfix[10]);
void inorder_non_recursive(node *t);
void inorder(node *p);
void preorder(node *p);
void postorder(node *p);
void preorder_non_recursive(node *t);
void postorder_non_recursion(node *t);

node* create_post(char postfix[10])
{node *p;
stack s;
	for(int i=0;postfix[i]!='\0';i++)
	{
		char token=postfix[i];
		if(isalnum(token))
		{
			p=new node();
			p->data=token;
			p->left=NULL;
			p->right=NULL;
			s.push(p);		
		}	
		else
		{
			p=new node();
			p->data=token;
			p->right=s.pop();
			p->left=s.pop();
			s.push(p);		
		}
	}
	return s.pop();
	
		
}

node* create_pre(char prefix[10])
{node *p;
stack s;
int i;
		for(i=0;prefix[i]!='\0';i++)
		{}
		i=i-1;
	for(;i>=0;i--)
	{
		char token=prefix[i];
		if(isalnum(token))
		{
			p=new node();
			p->data=token;
			p->left=NULL;
			p->right=NULL;
			s.push(p);		
		}	
		else
		{
			p=new node();
			p->data=token;
			p->left=s.pop();
			p->right=s.pop();
			s.push(p);		
		}
	}
	return s.pop();
	
		
}

int main()
{
	node *r=NULL,*r1;
	char postfix[10],prefix[10];
	int x;
int ch,choice;
do
{
	cout<<"\n\t****TREE OPERATIONS****\n1.Construct tree from postfix expression/ prefix expression\n2.Inorder traversal\n3.Preorder traversal\n4.Postorder traversal\n5.Exit\nEnter your choice=";
	cin>>ch;	
	switch(ch)
	{
		case 1:cout<<"ENTER CHOICE:\n1.Postfix expression\n2.Prefix expression\nchoice=";
			cin>>choice;
			if(choice==1)
			{
				cout<<"\nEnter postfix expression=";
				cin>>postfix;
				r=create_post(postfix);
			}
			else
			{	
				cout<<"\nEnter prefix expression=";
				cin>>prefix;
				r=create_pre(prefix);
			}	
			cout<<"\n\nTree created successfully";
			break;
		case 2:cout<<"\nInorder Traversal of tree:\n";
				inorder(r);
				cout<<"\n Without recursion:\t";
				inorder_non_recursive(r);
				break;
		case 3:cout<<"\nPreorder Traversal of tree:\n";
				preorder(r);
				cout<<"\npreorder traversal without recursion:\t";
				preorder_non_recursive(r);
				break;
		case 4:cout<<"\nPostorder Traversal of tree:\n";
				postorder(r);
				cout<<"\npostorder traversal without recursion";
				postorder_non_recursion(r);
				break;
	}
}while(ch!=5);
	return 0;
}

void inorder(node *p)
{
		if(p!=NULL)
		{
			inorder(p->left);
			cout<<p->data;
			inorder(p->right);	
		}
}

void preorder(node *p)
{
		if(p!=NULL)
		{
			cout<<p->data;
			preorder(p->left);
			preorder(p->right);	
		}
}


void postorder(node *p)
{
		if(p!=NULL)
		{
			postorder(p->left);
			postorder(p->right);
			cout<<p->data;	
		}
}




void inorder_non_recursive(node *t)
{

	stack s;
	while(t!=NULL)
	{
		s.push(t);
		t=t->left;
	}

	while(s.isempty()!=1)
	{
		t=s.pop();
		cout<<t->data;
		t=t->right;
		while(t!=NULL)
	{
		s.push(t);
		t=t->left;
	}


	}


}



void preorder_non_recursive(node *t)
{

	stack s;
	while(t!=NULL)
	{
		cout<<t->data;
		s.push(t);
		t=t->left;
	}

	while(s.isempty()!=1)
	{
		t=s.pop();
		
		t=t->right;
		while(t!=NULL)
	{
		cout<<t->data;
		s.push(t);
		t=t->left;
	}


	}
}

void postorder_non_recursion(node *t)
{stack s,s1;
node *t1;
	while(t!=NULL)
	{
		s.push(t);
		s1.push(NULL);
		t=t->left;			
	}
	while(s.isempty()!=1)
	{
		t=s.pop();
		t1=s1.pop();
		if(t1==NULL)
		{
			s.push(t);
			s1.push((node *)1);
			t=t->right;		
				while(t!=NULL)
				{
					s.push(t);
					s1.push(NULL);
					t=t->left;			
				}	
			
		}
		else
		cout<<t->data;	
	}


}

//END -------------------------------------------------------------------------------------

// BINARY SEARCH TREE -----------------------------------------------------------------------------

/*Implement binary search tree and perform following operations:
a. Insert
b. Delete
c. Search
d. Mirror image
e. Display
f. Display level wise
*/

#include<iostream>
using namespace std;

typedef struct tnode
{
     int data;
     struct tnode*left;
     struct tnode*right;
}tnode;

typedef struct node
{
   struct tnode*x;
   struct node *next;
}node;


class queue
{
   node *front,*rear;
   public:
queue()
{
   front=NULL;
   rear=NULL;
}

int isempty()
{
      if(front==NULL)
      return 1;
   return 0;
}
void enque(tnode *i)
{
   node *p;
   p=new node();
   p->x=i;
   p->next=NULL;
   
   if(front==NULL)
   {
     front=p;
     rear=p;
   }
   else
   {
     rear->next=p;
     rear=rear->next;
   }
}
tnode *deque()
{
  node *p;
  tnode *temp;
  p=front;
  temp=front->x;
  if(front==rear)
  {
     front=NULL;
     rear=NULL;
  }
  else
  {
     front=front->next;
  }
  delete p;
  return temp;
}
};



class tree
{
tnode *t;
public:
tree()
{
t=NULL;
}









tnode *insert(int x)
{
    tnode *p,*q,*r;
    
    p=new tnode();
    p->data=x;
    p->left=NULL;
    p->right=NULL;
    
    if(t==NULL)
    return p;
    
    q=t;
    r=t;
while(r!=NULL)
{
    q=r;
    if(x<r->data)
    r=r->left;
    else
    r=r->right;
}
    if(x<q->data)
    q->left=p;
    else
    q->right=p;

    return t;
}



tnode *create()
{
int n,i,key;
cout<<" \n Enter the number of nodes - ";
cin>>n;
for(i=0;i<n;i++)
{
cout<<" \n Enter the data -";
cin>>key;
t=insert(key);
}
return t;
}





void inorder(tnode *t)
{
if(t!=NULL)
{
inorder(t->left);
cout<<"\t"<<t->data;
inorder(t->right);
}
}




tnode* search(int key)
{ 
tnode *s=t;
while(s!=NULL)
{
if(s->data==key)
return t;
else if(s->data<key)
s=s->right;
else
s=s->left;

}
return NULL;
}





tnode *find_min(tnode *r)
{
while(r->left!=NULL)
{
r=r->left;
}
return r;
}





tnode *del(tnode *t,int key)
{
   tnode *temp;
   if(t==NULL)
   { 
     return NULL; 
   }
   if(key<t->data)
   {
     t->left=del(t->left,key);
     return t;
   }
   if(key>t->data)
   {
     t->right=del(t->right,key);
     return t;
   }
//element found
//no child
   if(t->left==NULL&t->right==NULL)
   { 
     temp=t;
     delete temp;
     return NULL;
   }
//one child
   if(t->left!=NULL&&t->right==NULL)
   {
     temp=t;
     t=t->left;
     delete temp;
     return t;
   }
   if(t->left==NULL&&t->right!=NULL)
   {
     temp=t;
     t=t->right;
     delete temp;
     return t;
   }
//both child present
 temp=find_min(t->right);
 t->data=temp->data;
 t->right=del(t->right,temp->data);
 return t;
}




tnode *mirror(tnode *t)
{
tnode *temp;
if(t==NULL)
{
return NULL;
}
temp=t->left;
t->left=mirror(t->right);
t->right=mirror(temp);
return t;
}






tnode* copy(tnode *T)
 {
 	tnode *P;
 	P=NULL;
 	if(T!=NULL)
 	{
 		P=new tnode();
 		P->data=T->data;
 		P->left=copy(T->left);
 		P->right=copy(T->right);
 	}
 	return P;
 }



int height(tnode *T)
{
	int hl,hr;
	if(T==NULL)
	return 0;
	if(T->left==NULL && T->right==NULL)
	return 0;
	hl=height(T->left);
	hr=height(T->right);
	if(hl>hr)
	return 1+hl;
	else
	return 1+hr;
	
}
void  leaf(tnode *T)
{

	if(T==NULL)
	return ;
	if(T->left==NULL && T->right==NULL)
	{	cout<<"\t"<<T->data;
			}	
  leaf(T->left);
  leaf(T->right);
	
}



void  parent(tnode *T)
{

	if(T==NULL)
	return ;
	if(T->left!=NULL && T->right==NULL)
	{	
	     cout<<"\t"<<T->data;
	     cout<<"\t"<<T->left->data;
	     cout<<"\n";
	}	
 
	if(T->left==NULL && T->right!=NULL)
	{	
	     cout<<"\t"<<T->data;
	     cout<<"\t"<<T->right->data;
	        cout<<"\n";
	}	
	
	
		if(T->left!=NULL && T->right!=NULL)
	{	
	     cout<<"\t"<<T->data;
	     cout<<"\t"<<T->left->data<<"\t"<<T->right->data;
	     cout<<"\n";
	}
	
	parent(T->left);
	parent(T->right);
}



void level_wise()
{
tnode *t1;
queue q1;
if(t==NULL)
return;
q1.enque(t);
cout<<"\n"<<t->data;
while(q1.isempty()!=1)
{
cout<<"\n";
queue q2;
while(q1.isempty()!=1)
{
t1=q1.deque();
if(t1->left!=NULL)
{
q2.enque(t1->left);
cout<<" "<<t1->left->data;
}
if(t1->right!=NULL)
{
q2.enque(t1->right);
cout<<" "<<t1->right->data;
}
}
q1=q2;
}
}



};

int main()
{   
     int choice,key, cnt;
     tnode *root,*result, *rt;
     tree t;
     do
     {
      cout<<" \n Main menu "
            "\n 1.Create "
            "\n 2.Insert "
            "\n 3.Display "
            "\n 4.Search "
            "\n 5.Delete "
            "\n 6.Mirror image "
            "\n 7.create copy "
            "\n 8.Find Depth "
            "\n 9.Minimum "
            "\n 10.Display Tree Level-wise "
            "\n 11.Display Leaf nodes "
            "\n 12.Display parent node with child nodes "
            "\n 13.Exit \n Enter your choice - ";
      cin>>choice;
     switch(choice)
     {
      case 1:root=t.create();
                 break;
      case 2:cout<<"\n Enter the number to insert - ";
             cin>>key; 
             root=t.insert(key);
             break;
      case 3:cout<<"Binary tree :-";
             t.inorder(root);
                 break;
      case 4:cout<<" \n Enter the node to search -";
                 cin>>key;
                 result=t.search(key);
                 if(result==NULL)
                 { 
                 cout<<"\n Element "<<key<<" not present"<<endl;
                 }
                 else
                 {
                 cout<<"\n Element "<<key<<" is present"<<endl;
                 }
                 break;
      case 5:cout<<"\n Enter the node to delete -";
             cin>>key;
             result=t.del(root,key);
             root=result;
             cout<<"\n Element deleted successfully!!"<<endl;    
         
             break;
      case 6:root=t.mirror(root);
             cout<<"\n Mirror image of the binary tree is :-"<<endl;
             t.inorder(root);
                 break;
             break;
      case 7: cout<<"\n Copied tree - ";
	  		rt=t.copy(root);   
	  		t.inorder(rt);
	  		break;    
	 
      case 8:cnt=t.height(root);
	        	cout<<"\n Height of tree -"<<cnt;
	  		break;	
	  
	     
      case 9:result=t.find_min(root);
             cout<<"\n Minimum is "<<result->data<<endl;
             break;
             
        case 10:cout <<"\n Level wise display :-"<<endl;
             t.level_wise();
             break;   
	case 11:cout <<"\n Leaf nodes are  :-"<<endl;
              t.leaf(root);  
             break;   	 
	case 12:cout <<"\n Parent node with child nodes are  :-"<<endl;
              t.parent(root);  
             break;   	
             
      case 13:return 0;
      default:cout<<"\n Invalid choice !! Please enter your choice again."<<endl;
     } 
     }while(choice!=13);
}


// END ------------------------------------------------------------------------

// THREADED BINARY TREE --------------------------------------------------------------

#include <iostream>
#include <cstdlib>

struct Node {
    int key;
    Node* left;
    Node* right;
    bool isThreaded; // true if right pointer is a thread
};

// Function to create a new node
Node* createNode(int key) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->left = nullptr;
    newNode->right = nullptr;
    newNode->isThreaded = false;
    return newNode;
}

// Function to insert a node into the threaded binary tree
Node* insert(Node* root, int key) {
    if (!root) {
        return createNode(key);
    }
    Node* current = root;
    Node* parent = nullptr;

    while (current) {
        parent = current;
        if (key < current->key) {
            if (current->left) {
                current = current->left;
            } else {
                break;
            }
        } else {
            if (current->right && !current->isThreaded) {
                current = current->right;
            } else {
                break;
            }
        }
    }

    Node* newNode = createNode(key);
    if (key < parent->key) {
        parent->left = newNode;
    } else {
        newNode->right = parent->right;
        newNode->isThreaded = true;
        parent->right = newNode;
        parent->isThreaded = false;
    }
    return root;
}

// Function to create in-order threading for the tree
void createInorderThreading(Node* node, Node*& prev) {
    if (!node) {
        return;
    }
    createInorderThreading(node->left, prev);
    if (prev && !prev->right) {
        prev->right = node;
        prev->isThreaded = true;
    }
    prev = node;
    createInorderThreading(node->right, prev);
}

// Function to find the leftmost node
Node* leftMost(Node* node) {
    while (node && node->left) {
        node = node->left;
    }
    return node;
}

// Function for in-order traversal
void inorderTraversal(Node* root) {
    Node* current = leftMost(root);
    while (current) {
        std::cout << current->key << " ";
        if (current->isThreaded) {
            current = current->right;
        } else {
            current = leftMost(current->right);
        }
    }
    std::cout << std::endl;
}

// Function for pre-order traversal
void preorderTraversal(Node* root) {
    Node* current = root;
    while (current) {
        std::cout << current->key << " ";
        if (current->left) {
            current = current->left;
        } else {
            while (current && current->isThreaded) {
                current = current->right;
            }
            current = current ? current->right : nullptr;
        }
    }
    std::cout << std::endl;
}

// Main function
int main() {
    Node* root = nullptr;
    int n, key;
    
    std::cout << "Enter the number of nodes: ";
    std::cin >> n;

    std::cout << "Enter the nodes:\n";
    for (int i = 0; i < n; i++) {
        std::cin >> key;
        root = insert(root, key);
    }

    Node* prev = nullptr;
    createInorderThreading(root, prev);

    std::cout << "In-order traversal:\n";
    inorderTraversal(root);

    std::cout << "Pre-order traversal:\n";
    preorderTraversal(root);

    return 0;
}

end-----------------------------------------------------------------

// MINIMUM SPANNING TREE      PRIMS ----------------------------------------------


/*primes*/
#include<iostream>
using namespace std;

class graph
{
 int G[20][20],n;
 
 public:
 
 void accept()
 {
  	int i,j,e;
  	int src,dest,cost;
	  cout<<"\nEnter the no. of vertices: ";
	  cin>>n;
	  
	  for(i=0;i<n;i++)
	  {
	  for(j=0;j<n;j++)
	  {
	  G[i][j]=0;
	  }
	  }
	  
	  cout<<"\nEnter the no. of  Edges: ";
	  cin>>e;
  
  
  
	  for(i=0;i<e;i++)
	  {
	  cout<<"\nEnter Source: ";
	   cin>>src;
	  cout<<"\nDestination: ";
	   cin>>dest;
	  cout<<"\nCost: ";
	  cin>>cost;
	  
	  G[src][dest]=cost;
	  G[dest][src]=cost;
 	 }
 	 
 	 
  }
  
  
  
  
  
  void display()
  {
  	int i,j;
   for(i=0;i<n;i++)
   {
   	cout<<"\n";
   	for(j=0;j<n;j++)
   	{
   		cout<<"\t"<<G[i][j];
   	}
   }
  }
  
  
  
  void prims()
  {
  	int i,j,R[20][20];
  	int src,dest,cost,count,min;
  	int total=0;
  	int visited[20];
  	
  	for(i=0;i<n;i++)
  	{
  		for(j=0;j<n;j++)
  		{
  			if(G[i][j]==0)
  			{
  				R[i][j]=999;
  			}
  		else
  		R[i][j]=G[i][j];
  		}
  	}
  	
  	
  	
  	for(i=0;i<n;i++)
  	{
  		visited[i]=0;
  	}
  	
  	cout<<"\nEnter start vertex: ";
  	cin>>src;
  	visited[src]=1;
  	
  	count=0;
  	while(count<n-1)
  	{
  	min=999;
  	
  	for(i=0;i<n;i++)
  	{
  	
  	if(visited[i]==1)
  	for(j=0;j<n;j++)
  	{
  	if(visited[j]!=1)
  	{
  	if(min>R[i][j])
  	{
  		min=R[i][j];
  		src=i;
  		dest=j;
  	}
  	}
  	}
  	}
  	
  	
  	cout<<"\nEdge from "<<src<<" to "<<dest<<" \twith cost:  "<<min;
  	total=total+min;
  	visited[dest]=1;
  	count++;
  	}
  	
  		cout<<"\nTotal Cost: "<<total<<"\n";
  	}

};

  
  int main()
  {
  graph g;
  g.accept();
  g.display();
  g.prims();
  }

//END ----------------------------------------------------------------------------


// MINIMUM SPANNING TREE           KRUSKALS ALGO --------------------------------------------


/*Represent any real world graph using adjacency list /adjacency matrix find minimum spanning
tree using Kruskal’s algorithm.*/
#include<iostream>
#define INFINITY 999
using namespace std;
class kruskal
{
typedef struct graph
{
int v1,v2,cost;
}GR;
GR G[20];
public:
int tot_edges,tot_nodes;
void create();
void spanning_tree();
void get_input();
int minimum(int);
};

int find(int v2,int parent[])
{
while(parent[v2]!=v2)
{
v2=parent[v2];
}
return v2;
}

void un(int i,int j,int parent[])
{
if(i<j)
parent[j]=i;
else
parent[i]=j;
}

void kruskal::get_input()
{
cout<<"\nEnter total number of nodes ";
cin>>tot_nodes;
cout<<"\nEnter total number of edges ";
cin>>tot_edges;
}

void kruskal::create()
{
for(int k=0;k<tot_edges;k++)
{
cout<<"\nEnter edges in (v1,v2) form: ";
cin>>G[k].v1>>G[k].v2;
cout<<"\nEnter corresponding cost ";
cin>>G[k].cost;
}
}

int kruskal::minimum(int n)
{
int i,small,pos;
small=INFINITY;
pos=-1;
for(i=0;i<n;i++)
{
if(G[i].cost<small)
{
small=G[i].cost;
pos=i;
}
}
return pos;
}

void kruskal::spanning_tree()
{
int count,k,v1,v2,i,j,tree[10][10],pos,parent[10];
int sum;
count=0;
k=0;
sum=0;
for(i=0;i<tot_nodes;i++)
parent[i]=i;
while(count!=tot_nodes-1)
{
pos=minimum(tot_edges);
if(pos==-1)
break;
v1=G[pos].v1;
v2=G[pos].v2;
i=find(v1,parent);
j=find(v2,parent);
if(i!=j)
{
tree[k][0]=v1;
tree[k][1]=v2;
k++;
count++;
sum+=G[pos].cost;
un(i,j,parent);
}
G[pos].cost=INFINITY;
}
if(count==tot_nodes-1)
{
cout<<"\nSpanning tree is: \n";
cout<<"\n---------------------------- \n";
for(i=0;i<tot_nodes-1;i++)
{
cout<<"|"<<tree[i][0];
cout<<" ";
cout<<tree[i][1]<<"|"<<endl;
}
cout<<"\n---------------------------- \n";
cout<<"cost of spanning tree is: "<<sum<<endl;
}
else
{
cout<<"there is no spanning tree "<<endl;
}
}

int main()
{
kruskal obj;
cout<<"\n\t Graph creation ";
obj.get_input();
obj.create();
obj.spanning_tree();
return 0;
}



//END ---------------------------------------------------------------------------------


// SHORTEST PATH ALGORITHM    DIJIKSTRA ALGO --------------------------------------------------

/*Represent a given graph using adjacency matrix /adjacency list and find the shortest path using
Dijkstra's algorithm (single source all destination).*/

#include<iostream>
using namespace std;

class graph
{
int g[20][20];
int e,v;
public:

void accept()
{
  int src,dest,cost,i,j;
  cout<<"\n Enter no. of vertices -";
  cin>>v;
  cout<<"\n Enter no. of edges ";
  cin>>e;
  for(i=0;i<v;i++)
  {
     for(j=0;j<v;j++)
     {
       g[i][j]=0;
     }
  }
 
  for(i=0;i<e;i++)
  {
     cout<<"\n Enter source and destination -";
     cin>>src>>dest;
     cout<<"\n Enter the cost of edges - ";
     cin>>cost;
     g[src][dest]=cost;
     g[dest][src]=cost;
}
}

void display()
{
  int i,j;
  for(i=0;i<v;i++)
  {
    cout<<endl;
  for(j=0;j<v;j++)
  {
    cout<<g[i][j]<<"\t";
  }
  }
}

void djikstra(int start)
{
  int r[20][20],mindst,next,cnt,i,j,visited[20],distance[20],from[20];
  
  for(i=0;i<v;i++)           //intialization of r[][]
  {
     for(j=0;j<v;j++)
     {
       if(g[i][j]==0)
        r[i][j]=9999; 
       else
        r[i][j]=g[i][j]; 
     }
  }
 
  for(i=0;i<v;i++)      //intialization of visited[],distance[],from[]
  {
     visited[i]=0;
     from[i]=start;
     distance[i]=r[start][i];
  }
     distance[start]=0;
     visited[start]=1;
     cnt=v;
  while(cnt>0)
  { 
    mindst=9999;
      for(i=0;i<v;i++)     
      {  
          if((mindst > distance[i] )&& visited[i]==0)
           {
               mindst=distance[i];
               next=i;
           }    
      }
 
    visited[next]=1;
    for(i=0;i<v;i++)     
      {
          if(visited[i]==0 && distance[i]>(mindst+r[next][i])) 
          {
             distance[i]=mindst+r[next][i];
             from[i]=next;
           }
      }
        cnt--;
}

for(i=0;i<v;i++)
 {
cout<<"\n Distance of "<<i<<" from "<<start<<" is "<<distance[i]<<endl<<" path "<<i;
 j=i;
do
{
j=from[j];
cout<<"<-"<<j;;
 }while(j!=start);
}
}

};

int main()
{
  int s;
  graph g;
  g.accept();
  g.display();
  cout<<endl<<"Enter the starting vertex -";
  cin>>s;
  g.djikstra(s);
  cout<<endl;
  return 0;
}



//END -------------------------------------------------------------------------------------

// IMPLEMENTATION OF HEAP SORT ------------------------------------------------------------------


#include <iostream>
 
using namespace std;
 
// A function to heapify the array.
void MaxHeapify(int a[], int i, int n)
{
	int j, temp;
	temp = a[i];
	j = 2*i;
 
 	while (j <= n)
	{
		if (j < n && a[j+1] > a[j])
		j = j+1;
		// Break if parent value is already greater than child value.
		if (temp > a[j])
			break;
		// Switching value with the parent node if temp < a[j].
		else if (temp <= a[j])
		{
			a[j/2] = a[j];
			j = 2*j;
		}
	}
	a[j/2] = temp;
	return;
}

void Build_MaxHeap(int a[], int n)
{
	int i;
	for(i = n/2; i >= 1; i--)
		MaxHeapify(a, i, n);
}

void Max_HeapSort(int a[], int n)
{
	int i, temp;
	for (i = n; i >= 2; i--)
	{
		// Storing maximum value at the end.
		temp = a[i];
		a[i] = a[1];
		a[1] = temp;
		// Building max heap of remaining element.
		MaxHeapify(a, 1, i - 1);
	}
}



void min_heapify(int a[],int i,int n)
{
    int j, temp;
    temp = a[i];
    j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j+1] < a[j])
            j = j + 1;
        if (temp < a[j])
            break;
        else if (temp >= a[j])
        {
            a[j/2] = a[j];
            j = 2 * j;
        }
    }
    a[j/2] = temp;
    return;
}
void build_minheap(int a[], int n)
{
    int i;
    for(i = n/2; i >= 1; i--)
    {
        min_heapify(a,i,n);
    }
}

void Min_HeapSort(int a[], int n)
{
	int i, temp;
	for (i = n; i >= 2; i--)
	{
		// Storing minimum value at the end.
		temp = a[i];
		a[i] = a[1];
		a[1] = temp;
		// Building max heap of remaining element.
		min_heapify(a, 1, i - 1);
	}
}

void print(int arr[], int n)
{
cout<<"\nSorted Data ";
 
	for (int i = 1; i <=n; i++)
		cout<<"->"<<arr[i];
 	return;
}



int main()
{
	int n, i, ch;
	cout<<"\nEnter the number of data element to be sorted: ";
	cin>>n;
	
	int arr[n];
	for(i = 1; i <=n; i++)
	{
		cout<<"Enter element "<<i<<": ";
		cin>>arr[i];
	}
	// Building max heap.
	
do
{	
cout<<"\n1. Heap sort using  max heap";
cout<<"\n2. Heap sort using  min heap";
cout<<"\n 3. exit";


cout<<"\nenter your choice:";
cin>>ch;
switch(ch)
{
case 1:	Build_MaxHeap(arr, n);
     	Max_HeapSort(arr, n);
       print(arr, n);
       break;	
case 2:	build_minheap(arr, n);
     	Min_HeapSort(arr, n);
        print(arr, n);
        break;	

case 3:return 0;
      default:cout<<"\n Invalid choice !! Please enter your choice again."<<endl;		
}
}
while(ch!=3);		

 

	

}

//END ------------------------------------------------------------------------------------------------


//FILE HANDLING ----------------------------------------------------------------------------

#include<iostream>
#include<fstream>
#include<stdio.h>
using namespace std;

typedef struct student
{
	int roll;
	char a,name[20],add[30];
}stud;
void create();
void display();
void insert();
void search(int key);
void delete1(int key);
void modify(int key);

int main()
{int ch,x;
do
{
	cout<<"\n\t***MENU***\n1.Accept\n2.Display\n3.Insert\n4.Search\n5.Delete\n6.Modify\n7.Exit\nEnter your choice=";
	cin>>ch;
	switch(ch)
	{
		case 1:create();
				break;
		case 2:display();
				break;
		case 3:insert();
				break;
		case 4: cout<<"Enter roll no to search=";
			cin>>x;
			search(x);
				break;
		case 5:cout<<"Enter roll no to delete=";
				cin>>x;
				delete1(x);
				break;
		case 6:cout<<"Enter roll no to modify=";
				cin>>x;
				modify(x);
				break;
	}
		
}while(ch!=7);

return 0;
}


ifstream fin;
ofstream fout;
fstream fm;
int n;
char fname[20];


void create()
{int i;
	stud s;
	cout<<"Enter name of the file=";
	cin>>fname;
	fm.open(fname,ios::out);

	cout<<"\nEnter no. of records:=";
	cin>>n;
	for(i=0;i<n;i++)
	{
		cout<<"Enter roll no=";
		cin>>s.roll;
		cout<<"Enter name=";
		cin>>s.name;
		cout<<"Enter division=";
		cin>>s.a;
		cout<<"Enter address=";
		cin>>s.add;
		fm.write((char*)&s,sizeof(s));
		
	}	

fm.close();
}//create

void display()
{int i;
stud s;
	fin.open(fname);
	cout<<"\nROLL NO\tNAME\tDIV\tADDRESS";
     //	while(!fin.eof())
     for(i=0;i<n;i++)
	{
		fin.read((char*)&s,sizeof(s));
		cout<<"\n"<<s.roll<<"\t"<<s.name<<"\t"<<s.a<<"\t"<<s.add;
	}
fin.close();
}//display

void insert()
{stud s;
		fout.open(fname,ios::app);
		cout<<"Enter roll no=";
		cin>>s.roll;
		cout<<"Enter name=";
		cin>>s.name;
		cout<<"Enter division=";
		cin>>s.a;
		cout<<"Enter address=";
		cin>>s.add;
		fout.write((char*)&s,sizeof(s));
		n++;
	fout.close();
}

void search(int key)
{  stud s;
int flag=0,i;

	fin.open(fname);

	for(i=0;i<n;i++)
	{
	    fin.read((char *)&s,sizeof(s));
	    if(s.roll==key)
	    {
		cout<<"\nRecord is present their corresponding details are:\nRoll no=";
		cout<<s.roll<<"\nName="<<s.name<<"\nDivision="<<s.a<<"\nAddress="<<s.add;
		flag=1;
	    }
	}
	if(flag==0)
	cout<<"\nRoll no.= "<<key<<" is not present in the record";

     fin.close();
}


void delete1(int key)
{  stud s;
int flag=0,i;

	fin.open(fname);
	fout.open("temp.txt",ios::out);

	for(i=0;i<n;i++)
	{
	    fin.read((char *)&s,sizeof(s));
	    if(s.roll==key)
	    {   cout<<"\nRecord deleted successfully";
			flag=1;
	    }
		else
		{
				    fout.write((char *)&s,sizeof(s));
		}
	}
	if(flag==0)
	cout<<"\nRoll no.= "<<key<<" is not present in the record";
	else
	n--;

     fin.close();
	 fout.close();

	 remove(fname);
	 rename("temp.txt",fname);
}

void modify(int key)
{  stud s;
int flag=0,i;

	fin.open(fname);
	fout.open("temp.txt",ios::out);

	for(i=0;i<n;i++)
	{
	    fin.read((char *)&s,sizeof(s));
	    if(s.roll==key)
	    {
				cout<<"Enter roll no=";
			cin>>s.roll;
			cout<<"Enter name=";
			cin>>s.name;
			cout<<"Enter division=";
			cin>>s.a;
			cout<<"Enter address=";
			cin>>s.add;
			fout.write((char*)&s,sizeof(s));

			flag=1;
	    }
		else
		{
				    fout.write((char *)&s,sizeof(s));

		}
	}
	if(flag==0)
	cout<<"\nRoll no.= "<<key<<" is not present in the record";

     fin.close();
	 fout.close();

	 remove(fname);
	 rename("temp.txt",fname);
}

//END ------------------------------------------------------------------------------------------------------------
